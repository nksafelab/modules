package jinke.readings.wedget;

import android.R;
import android.app.WallpaperManager;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.widget.Scroller;
import android.os.Parcelable;
import android.os.Parcel;

/**
 * 带listView事件响应的滑屏控件
 * 
 * @ClassName:Workspace
 *@Description:TODO(what to do)
 *@auchor: nk_jinke_yujinyang
 *@date:2011-9-22下午03:23:02
 *@tags:
 */
public class Workspace extends ViewGroup {
	private static final String TAG = "Workspace";

	private static final int INVALID_SCREEN = -1;

	public int mDefaultScreen;

	private boolean mFirstLayout = true;

	private int mCurrentScreen;
	private int mNextScreen = INVALID_SCREEN;
	public Scroller mScroller;
	// private VelocityTracker mVelocityTracker;

	private float mLastMotionX;
	private float mLastMotionY;

	private final static int TOUCH_STATE_REST = 0;
	private final static int TOUCH_STATE_SCROLLING = 1;

	private int mTouchState = TOUCH_STATE_REST;

	private int mTouchSlop;

	private int mCountScreen = 0;

	// private int mMaximumVelocity;

	// final Rect mDrawerBounds = new Rect();
	// final Rect mClipBounds = new Rect();
	// int mDrawerContentHeight;
	// int mDrawerContentWidth;

	/**
	 * Used to inflate the Workspace from XML.
	 * 
	 * @param context
	 *            The application's context.
	 * @param attrs
	 *            The attribtues set containing the Workspace's customization
	 *            values.
	 */
	public Workspace(Context context, AttributeSet attrs) {
		this(context, attrs, 0);
	}

	/**
	 * Used to inflate the Workspace from XML.
	 * 
	 * @param context
	 *            The application's context.
	 * @param attrs
	 *            The attribtues set containing the Workspace's customization
	 *            values.
	 * @param defStyle
	 *            Unused.
	 */
	public Workspace(Context context, AttributeSet attrs, int defStyle) {
		super(context, attrs, defStyle);

		// TypedArray a = context.obtainStyledAttributes(attrs,
		// com.girlcoding.www.R.styleable.Workspace, defStyle, 0);
		mDefaultScreen = 0;
		// a.recycle();

		initWorkspace();
	}

	/**
	 * Initializes various states for this workspace.
	 */
	private void initWorkspace() {
		mScroller = new Scroller(getContext());
		mCurrentScreen = mDefaultScreen;
		Log.e("initWorkspace", mDefaultScreen + "");
		final ViewConfiguration configuration = ViewConfiguration
				.get(getContext());
		mTouchSlop = configuration.getScaledTouchSlop();
		// mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
	}

	boolean isDefaultScreenShowing() {
		return mCurrentScreen == mDefaultScreen;
	}

	public int getCurrentScreen() {
		return mCurrentScreen;
	}

	void setCurrentScreen(int currentScreen) {
		mCurrentScreen = Math.max(0, Math.min(currentScreen,
				getChildCount() - 1));
		scrollTo(mCurrentScreen * getWidth(), 0);
		invalidate();
	}

	// add by luye 20111212
	@Override
	public void computeScroll() {
		if (mScroller.computeScrollOffset()) {
			// Log.d(TAG,"---compute "+mScroller.getCurrX()+","+getWidth());
			// if (mCurrentScreen==0)
			// scrollTo(mScroller.getCurrX()+100,mScroller.getCurrY());

			if (mCountScreen ==0){
				scrollTo(mScroller.getCurrX() +50, mScroller.getCurrY());
				Log.v("caca",""+mCurrentScreen);
			}

			if (mCountScreen == 1)
				scrollTo(mScroller.getCurrX() - 50, mScroller.getCurrY());
			if (mCountScreen == 2)
				scrollTo(mScroller.getCurrX()-50, mScroller.getCurrY());

		} else if (mNextScreen != INVALID_SCREEN) {
			mCurrentScreen = Math.max(0, Math.min(mNextScreen,
					getChildCount() - 1));

			mNextScreen = INVALID_SCREEN;
		}

	}

	@Override
	public boolean isOpaque() {
		return false;
	}

	// @Override
	// protected boolean drawChild(Canvas canvas, View child, long drawingTime)
	// {
	// // TODO Auto-generated method stub
	// super.drawChild(canvas, child, drawingTime);
	// getChildAt(mNextScreen);
	//    	
	//    	
	// return false;
	// }
	// protected boolean drawChildlu(Canvas canvas, View child, long
	// drawdingTime){
	//    	
	//    	
	// return false;
	// }
	@Override
	protected void dispatchDraw(Canvas canvas) {
		boolean restore = false;
		// ViewGroup.dispatchDraw() supports many features we don't need:
		// clip to padding, layout animation, animation listener, disappearing
		// children, etc. The following implementation attempts to fast-track
		// the drawing dispatch by drawing only what we know needs to be drawn.

		boolean fastDraw = mTouchState != TOUCH_STATE_SCROLLING
				&& mNextScreen == INVALID_SCREEN;
		// If we are not scrolling or flinging, draw only the current screen
		if (fastDraw) {
			if (getChildAt(mCurrentScreen) != null)
			// drawChild(canvas, getChildAt(mCurrentScreen), getDrawingTime());
			{
				final long drawingTime = getDrawingTime();
				final int count = getChildCount();
				for (int i = 0; i < count; i++) {
					drawChild(canvas, getChildAt(i), drawingTime);
				}
			}
		} else {
			final long drawingTime = getDrawingTime();
			// If we are flinging, draw only the current screen and the target
			// screen
			if (getChildAt(mCurrentScreen) != null)
				if (mNextScreen >= 0 && mNextScreen < getChildCount()
						&& Math.abs(mCurrentScreen - mNextScreen) == 1) {
					// drawChild(canvas, getChildAt(mCurrentScreen),
					// drawingTime);
					// drawChild(canvas, getChildAt(mNextScreen), drawingTime);

					final int count = getChildCount();
					for (int i = 0; i < count; i++) {
						drawChild(canvas, getChildAt(i), drawingTime);
					}

				} else {
					// If we are scrolling, draw all of our children
					final int count = getChildCount();
					for (int i = 0; i < count; i++) {
						drawChild(canvas, getChildAt(i), drawingTime);
					}
				}
		}

		if (restore) {
			canvas.restore();
		}
	}

	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		super.onMeasure(widthMeasureSpec, heightMeasureSpec);

		final int width = MeasureSpec.getSize(widthMeasureSpec);
		final int height = MeasureSpec.getSize(heightMeasureSpec);
		// Log.d(TAG,"--height is "+height);
		final int widthMode = MeasureSpec.getMode(widthMeasureSpec);

		if (widthMode != MeasureSpec.EXACTLY) {
			throw new IllegalStateException(
					"Workspace can only be used in EXACTLY mode.");
		}

		final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
		// Log.d(TAG,"----mode is "+heightMode);
		if (heightMode != MeasureSpec.EXACTLY) {
			throw new IllegalStateException(
					"Workspace can only be used in EXACTLY mode.");
		}

		// The children are given the same width and height as the workspace
		final int count = getChildCount();
		for (int i = 0; i < count; i++) {
			getChildAt(i).measure(widthMeasureSpec, heightMeasureSpec);
		}

		// add by luye 2011
		if (mFirstLayout) {
			scrollTo(mCurrentScreen * width + 50, 0);
			mFirstLayout = false;
		}
	}

	@Override
	protected void onLayout(boolean changed, int left, int top, int right,
			int bottom) {
		int childLeft = 0;

		final int count = getChildCount();
		for (int i = 0; i < count; i++) {
			final View child = getChildAt(i);
			if (child.getVisibility() != View.GONE) {
				final int childWidth = child.getMeasuredWidth();
				child.layout(childLeft, 0, childLeft + childWidth, child
						.getMeasuredHeight());
				childLeft += childWidth;
			}
		}
	}

	@Override
	public boolean dispatchUnhandledMove(View focused, int direction) {
		if (direction == View.FOCUS_LEFT) {
			if (getCurrentScreen() > 0) {
				snapToScreen(getCurrentScreen() - 1);
				return true;
			}
		} else if (direction == View.FOCUS_RIGHT) {
			if (getCurrentScreen() < getChildCount() - 1) {
				snapToScreen(getCurrentScreen() + 1);
				return true;
			}
		}
		return super.dispatchUnhandledMove(focused, direction);
	}

	@Override
	public boolean onInterceptTouchEvent(MotionEvent ev) {

		final int action = ev.getAction();
		if ((action == MotionEvent.ACTION_MOVE)
				&& (mTouchState != TOUCH_STATE_REST)) {
			return true;
		}

		final float x = ev.getX();
		final float y = ev.getY();

		switch (action) {
		case MotionEvent.ACTION_MOVE:
			/*
			 * mIsBeingDragged == false, otherwise the shortcut would have
			 * caught it. Check whether the user has moved far enough from his
			 * original down touch.
			 */

			/*
			 * Locally do absolute value. mLastMotionX is set to the y value of
			 * the down event.
			 */
			final int xDiff = (int) Math.abs(x - mLastMotionX);
			final int yDiff = (int) Math.abs(y - mLastMotionY);

			final int touchSlop = mTouchSlop;
			boolean xMoved = xDiff > touchSlop;
			boolean yMoved = yDiff > touchSlop;

			// if (xMoved || yMoved) {

			if (xMoved) {
				// Scroll if the user moved far enough along the X axis
				mTouchState = TOUCH_STATE_SCROLLING;
			}

			// }
			break;

		case MotionEvent.ACTION_DOWN:
			// Remember location of down touch
			mLastMotionX = x;
			mLastMotionY = y;

			/*
			 * If being flinged and user touches the screen, initiate drag;
			 * otherwise don't. mScroller.isFinished should be false when being
			 * flinged.
			 */
			mTouchState = mScroller.isFinished() ? TOUCH_STATE_REST
					: TOUCH_STATE_SCROLLING;
			break;

		case MotionEvent.ACTION_CANCEL:
		case MotionEvent.ACTION_UP:

			if (mTouchState != TOUCH_STATE_SCROLLING) {

			}

			// Release the drag
			mTouchState = TOUCH_STATE_REST;

			break;
		}

		/*
		 * The only time we want to intercept motion events is if we are in the
		 * drag mode.
		 */
		return mTouchState != TOUCH_STATE_REST;
	}

	@Override
	public boolean onTouchEvent(MotionEvent ev) {

		// if (mVelocityTracker == null) {
		// mVelocityTracker = VelocityTracker.obtain();
		// }
		// mVelocityTracker.addMovement(ev);

		final int action = ev.getAction();
		final float x = ev.getX();

		switch (action) {
		case MotionEvent.ACTION_DOWN:
			/*
			 * If being flinged and user touches, stop the fling. isFinished
			 * will be false if being flinged.
			 */
			if (!mScroller.isFinished()) {
				mScroller.abortAnimation();
			}

			// Remember where the motion event started
			mLastMotionX = x;
			break;
		case MotionEvent.ACTION_MOVE:
			if (mTouchState == TOUCH_STATE_SCROLLING) {
				// Scroll to follow the motion event
				final int deltaX = (int) (mLastMotionX - x);
				mLastMotionX = x;

				if (deltaX < 0) {
					if (getScrollX() > 0) {
						// Log.d(TAG,"--->0 cx is"+getScrollX()+",delta is "+deltaX);
						scrollBy(Math.max(-1 * getScrollX(), deltaX), 0);

					}
				} else if (deltaX > 0) {
					final int availableToScroll = getChildAt(
							getChildCount() - 1).getRight()
							- getScrollX() - getWidth();
					if (availableToScroll > 0) {
						// Log.d(TAG,"---<0 cx is"+availableToScroll+",delta is "+deltaX);
						scrollBy(Math.min(availableToScroll, deltaX), 0);

					}
				}
			}
			break;
		case MotionEvent.ACTION_UP:
			if (mTouchState == TOUCH_STATE_SCROLLING) {
				snapToDestination();
				// final VelocityTracker velocityTracker = mVelocityTracker;
				// velocityTracker.computeCurrentVelocity(1000,
				// mMaximumVelocity);
				// int velocityX = (int) velocityTracker.getXVelocity();
				//
				// if (velocityX > SNAP_VELOCITY && mCurrentScreen > 0) {
				// // Fling hard enough to move left
				// snapToScreen(mCurrentScreen - 1);
				// } else if (velocityX < -SNAP_VELOCITY && mCurrentScreen <
				// getChildCount() - 1) {
				// // Fling hard enough to move right
				// snapToScreen(mCurrentScreen + 1);
				// } else {
				// snapToDestination();
				// }
				//
				// if (mVelocityTracker != null) {
				// mVelocityTracker.recycle();
				// mVelocityTracker = null;
				// }
			}
			mTouchState = TOUCH_STATE_REST;
			break;
		case MotionEvent.ACTION_CANCEL:
			mTouchState = TOUCH_STATE_REST;
		}

		return true;
	}

	private void snapToDestination() {
		Log.d(TAG, "---dest");
		final int screenWidth = getWidth();
		
		final int whichScreen = (getScrollX() + (screenWidth / 2))
				/ screenWidth;

		if (whichScreen ==0){mCountScreen=0;
		Log.v("sssc",""+mCurrentScreen);}
		
		if (whichScreen ==1){mCountScreen=1;
		Log.v("sssc",""+mCurrentScreen);
		}
		
		if (whichScreen ==2){mCountScreen=2;
		Log.v("sssc",""+mCurrentScreen);
		}
		
		
		snapToScreen(whichScreen);
	}

	public void snapToScreen(int whichScreen) {
		if (!mScroller.isFinished())
			return;

		// Log.d(TAG,"---to "+whichScreen);

		whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));
		boolean changingScreens = whichScreen != mCurrentScreen;

		mNextScreen = whichScreen;

		View focusedChild = getFocusedChild();
		if (focusedChild != null && changingScreens
				&& focusedChild == getChildAt(mCurrentScreen)) {
			focusedChild.clearFocus();
		}

		final int cx = getScrollX();
		final int newX = whichScreen * getWidth();
		final int delta = newX - cx;
		Log.d(TAG, "---delta is " + delta + ",,, cx is " + cx);
		mScroller.startScroll(cx, 0, delta, 0, Math.abs(delta) * 4);
		invalidate();
	}

	public void moveToDefaultScreen() {
		Log.e("current", mDefaultScreen + "");
		snapToScreen(mDefaultScreen);
		getChildAt(mDefaultScreen).requestFocus();
	}

	@Override
	protected Parcelable onSaveInstanceState() {
		final SavedState state = new SavedState(super.onSaveInstanceState());
		state.currentScreen = mCurrentScreen;
		return state;
	}

	@Override
	protected void onRestoreInstanceState(Parcelable state) {
		SavedState savedState = (SavedState) state;
		super.onRestoreInstanceState(savedState.getSuperState());
		if (savedState.currentScreen != -1) {
			mCurrentScreen = savedState.currentScreen;

		}
	}

	public static class SavedState extends BaseSavedState {
		int currentScreen = -1;

		SavedState(Parcelable superState) {
			super(superState);
		}

		private SavedState(Parcel in) {
			super(in);
			currentScreen = in.readInt();
		}

		@Override
		public void writeToParcel(Parcel out, int flags) {
			super.writeToParcel(out, flags);
			out.writeInt(currentScreen);
		}

		public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
			public SavedState createFromParcel(Parcel in) {
				return new SavedState(in);
			}

			public SavedState[] newArray(int size) {
				return new SavedState[size];
			}
		};
	}
}
